# -*- coding: utf-8 -*-
"""Cnn_model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/raaaouf/7eba4d9dcdcd30ea1023d8a923e612d4/cnn_model.ipynb

this project is hosted on google colab to try it jusy press on the open in colab link

# Dataset :
[Covid-19 data on github  
](https://github.com/ieee8023/covid-chestxray-dataset) 

[Normal data on kaggle](https://https://www.kaggle.com/paultimothymooney/chest-xray-pneumonia/data#)

# Libraries
"""

from keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.layers import AveragePooling2D
from tensorflow.keras.layers import Dropout
from tensorflow.keras.layers import Flatten
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import Input
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.utils import to_categorical
from sklearn.preprocessing import LabelBinarizer
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from imutils import paths
import tensorflow as tf
from tensorflow.keras.datasets import cifar10
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Activation, Flatten
from tensorflow.keras.layers import Conv2D, MaxPooling2D
import pickle
import matplotlib.pyplot as plt
import numpy as np
import argparse
import cv2
import os
from tqdm import tqdm

"""# Creat the Dataset"""

DATADIR = "dataset"

CATEGORIES = ["Covid", "NotCovid"]

# Just for test
for category in CATEGORIES:  
    path = os.path.join(DATADIR,category)
    for img in os.listdir(path):  
        print(category,img, "\n") 
        img_array = cv2.imread(os.path.join(path,img)) 
        plt.imshow(img_array)  # graph it
        plt.show()  # display!
        break

dataSet = []
IMG_SIZE = 224

def create_training_data():
    for category in CATEGORIES:  

        path = os.path.join(DATADIR,category) 
        print(path)
        class_num = CATEGORIES.index(category)  # get the classification  (0 or a 1). 0=Covid+ 1=Covid-
        print(class_num)
        for img in tqdm(os.listdir(path)):  
            try:
                img_array = cv2.imread(os.path.join(path,img))  # convert to array
                new_array = cv2.resize(img_array, (IMG_SIZE, IMG_SIZE))  # resize to normalize data size
                dataSet.append([new_array, class_num])  # add this to our dataset
            except Exception as e:  # in the interest in keeping the output clean...
            #except OSError as e:
                print("OSErrroBad img most likely", e, os.path.join(path,img))
            #except Exception as e:
                print("general exception", e, os.path.join(path,img))

create_training_data()

print(len(dataSet))

import random

random.shuffle(dataSet)

for sample in dataSet[:10]:
    print(sample[1])

# grab the list of images in our dataset directory, then initialize
# the list of data (i.e., images) and class images

X = []
y = []

for features,label in dataSet:
  features = cv2.resize(features, (224, 224))
  X.append(features)
  y.append(label)
  # y = np.array(label)





# X = np.array(X).reshape(IMG_SIZE, IMG_SIZE)  / 255.0
# # X = np.array(X) / 255.0
# y = np.array(y)
# # X = X/255.0

X = np.array(X) / 255.0
y = np.array(y)
# X = X/255.0

"""### Create the *Training* and *Validation* datasets

---
"""

from sklearn.model_selection import train_test_split

(trainX, testX, trainY, testY) = train_test_split(X, y,
	test_size=0.20, stratify=y, random_state=42)

y

trainY

import pickle

pickle_out = open("X.pickle","wb")
pickle.dump(X, pickle_out)
pickle_out.close()

pickle_out = open("y.pickle","wb")
pickle.dump(y, pickle_out)
pickle_out.close()

"""# Model settings"""

# initialize the training data augmentation object
trainAug = ImageDataGenerator(
	rotation_range=15,
	fill_mode="nearest")

INIT_LR = 1e-3
EPOCHS = 15
BS = 8

"""# Model1:"""

# 2ed Model


nClasses = 2
model2 = Sequential()

model2.add ( Conv2D ( 32 , ( 3 , 3 ), padding= 'same' , activation= 'relu'))
model2.add ( Conv2D ( 32 , ( 3 , 3 ), activation= 'relu' ))
model2.add ( MaxPooling2D ( pool_size= ( 2 , 2 )))
model2.add ( Dropout ( 0.5 ))
model2.add ( Conv2D ( 64 , ( 3 , 3 ), padding= 'same' , activation= 'relu' ))
model2.add ( Conv2D ( 64 , ( 3 , 3 ), activation= 'relu' ))
model2.add ( MaxPooling2D ( pool_size= ( 2 , 2 )))
model2.add ( Dropout ( 0.5 ))
model2.add ( Conv2D ( 64 , ( 3 , 3 ), padding= 'same' , activation= 'relu' ))
model2.add ( Conv2D ( 64 , ( 3 , 3 ), activation= 'relu' ))
model2.add ( MaxPooling2D ( pool_size= ( 2 , 2 )))
model2.add ( Dropout ( 0.5 ))
model2.add ( Flatten ())
model2.add ( Dense ( 512 , activation= 'sigmoid' ))
model2.add ( Dropout ( 0.4 ))
model2.add ( Dense ( nClasses , activation= 'sigmoid'))



opt = Adam(lr=INIT_LR, decay=INIT_LR / EPOCHS)
model2.compile(loss="binary_crossentropy", optimizer=opt,
	metrics=["accuracy"])



history2 = model2.fit_generator(
	trainAug.flow(trainX, trainY, batch_size=BS),
	steps_per_epoch=len(trainX) // BS,
	validation_data=(testX, testY),
	validation_steps=len(testX),
	epochs=EPOCHS)

"""# Model 2:"""

model = Sequential()


model.add(Conv2D(256, (3, 3), input_shape=X.shape[1:]))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(256, (3, 3)))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Flatten())  # this converts our 3D feature maps to 1D feature vectors

model.add(Dense(64))

model.add(Dense(1))
model.add(Activation('sigmoid'))



opt = Adam(lr=INIT_LR, decay=INIT_LR / 20)
model.compile(loss="binary_crossentropy", optimizer=opt,
	metrics=["accuracy"])



history1 = model.fit_generator(
	trainAug.flow(trainX, trainY, batch_size=BS),
	steps_per_epoch=len(trainX) // BS,
	validation_data=(testX, testY),
	validation_steps=len(testX),
	epochs=20)

"""# Testing & Prediction"""

# *** TO DO : testing & Prediction

import matplotlib.pyplot as plt
from sklearn.metrics import classification_report


# make predictions on the testing set
predIdxs = model.predict(testX, batch_size=BS)

testY

# Prediction

import random
import cv2 

try:
    from google.colab.patches import cv2_imshow
except Exception:
    def cv2_imshow(mat):
        return cv2.imshow('img', mat)

def url_to_image(url):
    from skimage import io
    return cv2.cvtColor(io.imread(url), cv2.COLOR_BGR2RGB)

    
def convertData(image):
    img = image.astype('float32')
    img /= 255
    c = np.zeros(224*224*3).reshape((1,224,224,3))
    c[0] = img
    return c

_labels = np.array([
  'PosCovid-19', # class 0
  'NegCovid-19'])# class 1

def CasePrediction(url):
  img = url_to_image(url)
  img = resized = cv2.resize(img, (224,224)) 

  plt.figure(figsize=(16,16))
  data = convertData(img)
  plt.imshow(img)
  ret = model.predict(data, batch_size=BS) 
  bestnum = 0.0
  bestclass = 0

  if  ret[0] < 0.5:
      bestclass = 0
  else :
      bestclass = 1



  plt.title(_labels[bestclass])
                                                    
  plt.show()

# Pos Ex.
urlp = 'https://a.top4top.io/p_15402pp5p3.png'
# Neg Ex.
urln = 'https://k.top4top.io/p_1540g20th1.jpeg'

CasePrediction(urlp)
CasePrediction(urln)

"""# Ploting"""

history1.history.keys()

import matplotlib.pyplot as plt
print("Model : 1")
plt.style.use("ggplot")
plt.figure()
plt.plot(history1.history['acc'], label='Training accuracy')
plt.plot(history1.history['val_acc'], label='Validation accuracy')
plt.plot(history1.history['loss'], label='Training loss')
plt.plot(history1.history['val_loss'], label='Validation loss')
plt.xlim(left=1)
plt.ylim(top=1.1)
plt.legend()
plt.show()
print("Model : 2")
plt.style.use("ggplot")
plt.figure()
plt.plot(history2.history['acc'], label='Training accuracy')
plt.plot(history2.history['val_acc'], label='Validation accuracy')
plt.plot(history2.history['loss'], label='Training loss')
plt.plot(history2.history['val_loss'], label='Validation loss')
plt.xlim(left=1)
plt.ylim(top=1.1)
plt.legend()
plt.show()

# To Do: Fix

"optionnal: confusion matrix"

"""# Model 3"""

# TO DO: try this model 

img_width = 224
img_height = 224
epochs = 100

base_model = tf.keras.applications.MobileNet(weights='imagenet', include_top=False, 
                                             input_shape=(img_width, img_height, 3))

output = tf.keras.layers.GlobalAveragePooling2D()(base_model.output)
output = tf.keras.layers.Dense(2, activation='softmax')(output)

model1 = tf.keras.Model(inputs=base_model.input, outputs=output)

model1.compile(optimizer=tf.keras.optimizers.Adam(lr=0.0001), 
              loss='categorical_crossentropy', metrics=['accuracy'])

model1.summary()